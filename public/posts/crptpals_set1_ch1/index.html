<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Cryptopals - Set 1 - Convert hex to base64 :: Paolo Broglio</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Input: 49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Output: SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t Step 1 Objective: get raw bytes starting from hex string
We can&rsquo;t work on the input string as it is, we need to extract bytes We know that in hexadecimal representation every digit can be represented by 4 bits in computers for example: `11 (base10) -&gt; A (base16) -&gt; 1010 (base2) So now we have to group the string&rsquo;s chars group hex string chars by 2 since in the end we need a byte (a.k.a. 2 groups of 4 bits) quick note: this can result in an out of bounds error if the string&rsquo;s length is odd, but working with bytes it should never happen that a hexadecimal representation of such bytes contains an odd number of characters Then if you use strconv.ParseUint(slice, 16, 8) you easily obtain the actual byte. Doing it for the whole length of the string you&rsquo;ll have a byte array. func convertHexStringToByteArray(hexString string) ([]byte, error) { byteArray := make([]byte, len(hexString)/2) for i := 0; i &lt; len(hexString); i &#43;= 2 { b, err := strconv.ParseUint(hexString[i:i&#43;2], 16, 8) if err != nil { return nil, err } byteArray[i/2] = byte(b) } return byteArray, nil } Input: 49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Output: [73 39 109 32 107 105 108 108 105 110 103 32 121 111 117 114 32 98 114 97 105 110 32 108 105 107 101 32 97 32 112 111 105 115 111 110 111 117 115 32 109 117 115 104 114 111 111 109] Step 2 Objective: get the encoded string starting from raw bytes
" />
<meta name="keywords" content="base64, go, cryptopals" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/crptpals_set1_ch1/" />





  
  <link rel="stylesheet" href="http://localhost:1313/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/code.min.00125962708925857e7b66dbc58391d55be1191a3d0ce2034de8c9cd2c481c36.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/main.min.fe8dc560fccb53a458b0db19ccb7b265764ac46b68596b7e099c6793054dd457.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terminal.min.b52cf307864fd3ffa5f63cd601536884dc342faf57bd06aec7171142ed144a2d.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Cryptopals - Set 1 - Convert hex to base64">
<meta property="og:description" content="Input: 49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Output: SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t Step 1 Objective: get raw bytes starting from hex string
We can&rsquo;t work on the input string as it is, we need to extract bytes We know that in hexadecimal representation every digit can be represented by 4 bits in computers for example: `11 (base10) -&gt; A (base16) -&gt; 1010 (base2) So now we have to group the string&rsquo;s chars group hex string chars by 2 since in the end we need a byte (a.k.a. 2 groups of 4 bits) quick note: this can result in an out of bounds error if the string&rsquo;s length is odd, but working with bytes it should never happen that a hexadecimal representation of such bytes contains an odd number of characters Then if you use strconv.ParseUint(slice, 16, 8) you easily obtain the actual byte. Doing it for the whole length of the string you&rsquo;ll have a byte array. func convertHexStringToByteArray(hexString string) ([]byte, error) { byteArray := make([]byte, len(hexString)/2) for i := 0; i &lt; len(hexString); i &#43;= 2 { b, err := strconv.ParseUint(hexString[i:i&#43;2], 16, 8) if err != nil { return nil, err } byteArray[i/2] = byte(b) } return byteArray, nil } Input: 49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d Output: [73 39 109 32 107 105 108 108 105 110 103 32 121 111 117 114 32 98 114 97 105 110 32 108 105 107 101 32 97 32 112 111 105 115 111 110 111 117 115 32 109 117 115 104 114 111 111 109] Step 2 Objective: get the encoded string starting from raw bytes
" />
<meta property="og:url" content="http://localhost:1313/posts/crptpals_set1_ch1/" />
<meta property="og:site_name" content="Paolo Broglio" />

  
  
  <meta property="og:image" content="http://localhost:1313/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-01-21 16:07:18 &#43;0100 CET" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Paolo Broglio
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="https://github.com/paolobroglio">GitHub</a></li>
        
      
        
          <li><a href="/posts">Posts</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="https://github.com/paolobroglio" >GitHub</a></li>
        
      
        
          <li><a href="/posts" >Posts</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/posts/crptpals_set1_ch1/">Cryptopals - Set 1 - Convert hex to base64</a>
  </h1>
  <div class="post-meta"><time class="post-date">21 Jan 2025</time><span class="post-author">Paolo Broglio</span></div>

  
    <span class="post-tags">
      
      #<a href="http://localhost:1313/tags/cryptography/">cryptography</a>&nbsp;
      
      #<a href="http://localhost:1313/tags/challenge/">challenge</a>&nbsp;
      
      #<a href="http://localhost:1313/tags/go/">go</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <pre tabindex="0"><code>Input: 
49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d

Output:
SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t
</code></pre><h2 id="step-1">Step 1<a href="#step-1" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>Objective: get raw bytes starting from hex string</strong></p>
<ul>
<li>We can&rsquo;t work on the input string as it is, we need to extract bytes</li>
<li>We know that in hexadecimal representation every digit can be represented by 4 bits in computers
<ul>
<li>for example: `11 (base10) -&gt; A (base16) -&gt; 1010 (base2)</li>
</ul>
</li>
<li>So now we have to group the string&rsquo;s chars
<ul>
<li>group hex string chars by <strong>2</strong> since in the end we need a <strong>byte</strong> (a.k.a. 2 groups of 4 bits)
<ul>
<li><strong>quick note:</strong> this can result in an out of bounds error if the string&rsquo;s length is odd, but working with bytes <em>it should never happen</em> that a hexadecimal representation of such bytes contains an odd number of characters</li>
</ul>
</li>
</ul>
</li>
<li>Then if you use <code>strconv.ParseUint(slice, 16, 8)</code> you easily obtain the actual byte. Doing it for the whole length of the string you&rsquo;ll have a byte array.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convertHexStringToByteArray</span>(<span style="color:#a6e22e">hexString</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">byteArray</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, len(<span style="color:#a6e22e">hexString</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">hexString</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseUint</span>(<span style="color:#a6e22e">hexString</span>[<span style="color:#a6e22e">i</span>:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">byteArray</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>] = byte(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">byteArray</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>Input:
49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d

Output:
[73 39 109 32 107 105 108 108 105 110 103 32 121 111 117 114 32 98 114 97 105 110 32 108 105 107 101 32 97 32 112 111 105 115 111 110 111 117 115 32 109 117 115 104 114 111 111 109]
</code></pre><h2 id="step-2">Step 2<a href="#step-2" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p><strong>Objective: get the encoded string starting from raw bytes</strong></p>
<ul>
<li>Base64 encoding requires to split the bytes array in <strong>groups of 3 bytes</strong>, but of course if the length of the array is not a multiple of 3 we could end up having an out of bounds error. This time is crucial to address the issue</li>
</ul>
<h3 id="step-21">Step 2.1<a href="#step-21" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>Objective: add padding to the bytes sequence</strong></p>
<ul>
<li>To prevent the out of bounds error we can add a padding at the end of the bytes sequence</li>
<li>We must add zeroes to the end of the sequence if its length is not a <strong>multiple of 3</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">padding</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">data</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">padding</span> &gt; <span style="color:#ae81ff">0</span> { 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; (<span style="color:#ae81ff">3</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">padding</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { 
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">data</span>, <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="step-22">Step 2.2<a href="#step-22" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>Objective: from 3 bytes to one integer</strong></p>
<ul>
<li>First thing to do is to go through the bytes sequence in groups of three bytes
<ul>
<li><code>for i := 0; i &lt; len(bytes); i += 3</code> easy enough</li>
</ul>
</li>
<li>Then enter the bitwise operations
<ul>
<li>We need to <strong>combine the 3 bytes into a single integer</strong> and since we have single bytes we have to use the <strong>OR</strong> on their bit representation to combine them together</li>
<li>Since there are three of them, the computation is as it follows:
<ul>
<li>First byte needs left shifting by <strong>16 bits</strong></li>
<li>Second byte needs left shifting by <strong>8 bits</strong></li>
<li>Third byte is considered as it is</li>
</ul>
</li>
<li><code>b := (int(bytes[i]) &lt;&lt; 16) + (int(bytes[i+1] &lt;&lt; 8)) + (int(bytes[i+2]))</code></li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>b = (65 &lt;&lt; 16) + (66 &lt;&lt; 8) + (67)
  = (01000001 &lt;&lt; 16) + (01000010 &lt;&lt; 8) + (01000011)
  = 01000001 00000000 + 00000010 01000000 + 00000000
  = 01000001 01000010 01000011
</code></pre><ul>
<li>Now that we have our <strong>24 bit</strong> integer we can go ahead with the next step</li>
</ul>
<h3 id="step-23">Step 2.3<a href="#step-23" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>Objective: base64 representation</strong></p>
<ul>
<li>Last step of the base64 encoding is to group those 24 bits in 4 <strong>6 bits groups</strong> and get the corresponding base64 character <a href="https://datatracker.ietf.org/doc/html/rfc4648#section-4">according to the specification</a></li>
<li>Each group can be obtained doing the exact opposite of what we did on the previous step, meaning we need to do a <strong>right shifting</strong> for each group of 6 bits
<ul>
<li>group1: b &raquo; 18</li>
<li>group2: b &raquo; 12</li>
<li>group3: b &raquo; 6</li>
<li>group4: b</li>
</ul>
</li>
<li>After that we need to use an <strong>AND</strong> operation to extract only the last 6 bits, and since we&rsquo;re only interested in numbers included in <strong>0-63 range</strong> (here&rsquo;re the why of base64) we can use the bit mask <strong>00111111</strong> (0x3F) as the second operand of the AND operation.
<ul>
<li>This shares some similarities to the <strong>% (modulus)</strong> operation that lets you restrict a value in a certain range</li>
</ul>
</li>
<li>Then using the specification&rsquo;s table we can fetch the corresponding base64 character for each 6 bits group</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">encoded</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">bytes</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">3</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> (int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">i</span>]) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>) <span style="color:#f92672">+</span> (int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">+</span> (int(<span style="color:#a6e22e">bytes</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>]))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">group1</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">base64Chars</span>[(<span style="color:#a6e22e">b</span><span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">18</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0x3F</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">group2</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">base64Chars</span>[(<span style="color:#a6e22e">b</span><span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">12</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0x3F</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">group3</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">base64Chars</span>[(<span style="color:#a6e22e">b</span><span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">6</span>)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0x3F</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">group4</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">base64Chars</span>[<span style="color:#a6e22e">b</span><span style="color:#f92672">&amp;</span><span style="color:#ae81ff">0x3F</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">encoded</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">group1</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">group2</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">group3</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">group4</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We need to repeat this every 3 bytes and in the end we will have the encoded string</li>
</ul>
<h3 id="step-24">Step 2.4<a href="#step-24" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><strong>Objective: encoded string padding</strong></p>
<ul>
<li>Similarly to what we did on Step 2.1 we need to check and eventually add some padding symbols to the encoded string. If you ever saw a base64 string you probably noticed that sometimes there are <code>=</code> symbols at the end of the string. That&rsquo;s the padding.</li>
<li>We can reuse the Step 2.1 logic and attach one or two <code>=</code> symbols depending on the bytes array length</li>
</ul>

      </div></div>

  
    

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Â© 2025 Paolo Broglio</span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
